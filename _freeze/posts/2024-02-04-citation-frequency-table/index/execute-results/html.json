{
  "hash": "76b54aa7db0db6772cb9d6e32a659a63",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Citation Frequency Table\"\nsubtitle: \"\"\ndescription: \"\"\ndate: \"2024-02-04\"\nimage-alt: \"\"\ncategories: [Utility, Shiny]\ndate-modified: \"2024-02-06\"\ndraft: FALSE\nfilters:\n  - shinylive\n---\n\n::: {.cell}\n::: {.cell-output-display}\n![](../../Images/AdobeStock_646043882.jpeg){width=3168}\n:::\n:::\n\n\nThis is a serverless app that lets you upload your Word document and outputs a table of citations frequencies, which you can download as csv and Excel formats. A serverless app runs entirely in your browser so your uploaded file stays on your computer. It does not leave the computer. **You can use it even without an Internet connection _once it is fully initialized in the browser_.**\n\nThe downside of a serverless app is that there will be some delay to initialize it, so please be patient!\n\nIt currently works only for the *Journal of Marketing* and the *Journal of Marketing Research* citation styles. Crucially, multiple citations should be separated by a semicolon. The app will return only the citations that are in parentheses. For example it will return *(Tuli and Bharadwaj 2009)* but can't return *Tuli and Bharadwaj (2009)* because the regex for such a task is not easy. But, I am working on it. Please email me [ashwin.malshe at utsa.edu] in case you have any issues. \n\nThank you for your patience while the app is loading.\n\n```{shinylive-r}\n#| standalone: true\n#| viewerHeight: 750\n\nlibrary(shiny)\nlibrary(officer)\nlibrary(stringr)\nlibrary(bslib)\nlibrary(shinycssloaders)\nlibrary(DT)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nui = page_sidebar(\n  theme = bs_theme(bootswatch = \"cosmo\"),\n  title = \"\",\n  sidebar = sidebar(\n    fileInput(\"mydoc\", \"Upload a Word document (.docx extension)\"),\n    actionButton(\"run\", \"Get Frequency\")\n  ),\n  shinycssloaders::withSpinner(dataTableOutput(\"tab1\"), type = 5)\n)\n\nserver = function(input, output, session) {\n  \n  output$tab1 = renderDataTable(NULL)\n  \n  observeEvent(input$run, {\n    output$tab1 = renderDataTable({\n      \n      pattern_updated = \"\\\\(((?![^\\\\)]*accessed)[\\\\w\\\\s,.&;-]+? \\\\d{4}(?:;[\\\\w\\\\s,.&;-]+? \\\\d{4})*?)\\\\)\"\n      \n      texts = read_docx(isolate(input$mydoc$datapath)) |> docx_summary()\n      full_text = paste(texts$text, collapse = \" \")\n      citations_updated = str_extract_all(full_text, pattern_updated)[[1]]\n      flat_citations = unlist(str_split(citations_updated, \";\"))\n      flat_citations = str_replace_all(flat_citations, \"e.g.,\", \"\") |> \n        trimws()\n      Papers = str_replace_all(flat_citations, \"\\\\(|\\\\)\", \"\")\n      citation_counts_updated = table(Papers)\n      sorted_citations_updated = sort(citation_counts_updated, decreasing = TRUE) \n      \n      freq_tab = data.frame(sorted_citations_updated)\n      \n      return(freq_tab)\n      \n    },\n    caption = htmltools::tags$caption(style = 'caption-side: top; color:black;', \n                                      paste(\"Filename:\", isolate(input$mydoc$name))),\n    server = FALSE, # outputs entire table. Otherwise only the visible table.\n    extensions = 'Buttons', \n    options = list(dom = 'Bfrtip',\n                   buttons = list('copy',\n                                  list(extend='csv', filename = gsub(\"\\\\.docx?\\\\b\",\"\", isolate(input$mydoc$name))),\n                                  list(extend='excel', filename = gsub(\"\\\\.docx?\\\\b\",\"\", isolate(input$mydoc$name)))\n                                  ))\n    )# belongs to renderDataTable\n    \n  }) # belongs to observeEvent\n  \n}\n\n\n\nshiny::shinyApp(ui, server)\n```\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}